// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateSession = `-- name: CreateSession :exec
insert into sessions ( access_token, user_id) values ($1,$2)
`

type CreateSessionParams struct {
	AccessToken string `json:"accessToken"`
	UserID      int64  `json:"userId"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.Exec(ctx, CreateSession, arg.AccessToken, arg.UserID)
	return err
}

const CreateUser = `-- name: CreateUser :one
insert into users (email, name, password, user_role) values ($1,$2,$3,$4) returning id
`

type CreateUserParams struct {
	Email    string       `json:"email"`
	Name     string       `json:"name"`
	Password string       `json:"password"`
	UserRole UserRoleType `json:"userRole"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, CreateUser,
		arg.Email,
		arg.Name,
		arg.Password,
		arg.UserRole,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const CreateUserLog = `-- name: CreateUserLog :exec
insert into user_logs (user_id, event, request_url, data, status, error_message) values ($1,$2,$3,$4,$5,$6)
`

type CreateUserLogParams struct {
	UserID       pgtype.Int8 `json:"userId"`
	Event        string      `json:"event"`
	RequestUrl   string      `json:"requestUrl"`
	Data         []byte      `json:"data"`
	Status       int32       `json:"status"`
	ErrorMessage pgtype.Text `json:"errorMessage"`
}

func (q *Queries) CreateUserLog(ctx context.Context, arg CreateUserLogParams) error {
	_, err := q.db.Exec(ctx, CreateUserLog,
		arg.UserID,
		arg.Event,
		arg.RequestUrl,
		arg.Data,
		arg.Status,
		arg.ErrorMessage,
	)
	return err
}

const DeleteSession = `-- name: DeleteSession :exec
delete from sessions where user_id =$1 and access_token =$2
`

type DeleteSessionParams struct {
	UserID      int64  `json:"userId"`
	AccessToken string `json:"accessToken"`
}

func (q *Queries) DeleteSession(ctx context.Context, arg DeleteSessionParams) error {
	_, err := q.db.Exec(ctx, DeleteSession, arg.UserID, arg.AccessToken)
	return err
}

const DeleteUser = `-- name: DeleteUser :exec
delete  from users where  id =  $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, DeleteUser, id)
	return err
}

const GetSession = `-- name: GetSession :one
select id, created_at, updated_at, access_token, user_id from  sessions where user_id =$1 and access_token =$2
`

type GetSessionParams struct {
	UserID      int64  `json:"userId"`
	AccessToken string `json:"accessToken"`
}

func (q *Queries) GetSession(ctx context.Context, arg GetSessionParams) (Sessions, error) {
	row := q.db.QueryRow(ctx, GetSession, arg.UserID, arg.AccessToken)
	var i Sessions
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.UserID,
	)
	return i, err
}

const GetUserLogs = `-- name: GetUserLogs :many
select id, created_at, updated_at, user_id, event, request_url, data, status, error_message from user_logs where (user_id = $1 or $1 is  null) order by id desc limit  $2 offset $3
`

type GetUserLogsParams struct {
	UserID pgtype.Int8 `json:"userId"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) GetUserLogs(ctx context.Context, arg GetUserLogsParams) ([]UserLogs, error) {
	rows, err := q.db.Query(ctx, GetUserLogs, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserLogs
	for rows.Next() {
		var i UserLogs
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Event,
			&i.RequestUrl,
			&i.Data,
			&i.Status,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUserLogsCount = `-- name: GetUserLogsCount :one
select count(*) from user_logs where (user_id = $1 or $1 is null)
`

func (q *Queries) GetUserLogsCount(ctx context.Context, userID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, GetUserLogsCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetUsers = `-- name: GetUsers :many
select id, created_at, updated_at, email, name, password, user_role from users where (id = $1 or $1 = 0) and (email = $2 or $2 = '') and (user_role::text like $3 or $3 = '%%') and (name like $4 or $4 = '%%') order by id desc limit $5 offset $6
`

type GetUsersParams struct {
	ID       int64        `json:"id"`
	Email    string       `json:"email"`
	UserRole UserRoleType `json:"userRole"`
	Name     string       `json:"name"`
	Limit    int32        `json:"limit"`
	Offset   int32        `json:"offset"`
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]Users, error) {
	rows, err := q.db.Query(ctx, GetUsers,
		arg.ID,
		arg.Email,
		arg.UserRole,
		arg.Name,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Users
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.Name,
			&i.Password,
			&i.UserRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsersCount = `-- name: GetUsersCount :one
select count(*) from users where (id = $1 or $1 = 0) and (email = $2 or $2 = '') and (user_role::text like $3 or $3 = '%%') and (name like $4 or $4 = '%%')
`

type GetUsersCountParams struct {
	ID       int64        `json:"id"`
	Email    string       `json:"email"`
	UserRole UserRoleType `json:"userRole"`
	Name     string       `json:"name"`
}

func (q *Queries) GetUsersCount(ctx context.Context, arg GetUsersCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, GetUsersCount,
		arg.ID,
		arg.Email,
		arg.UserRole,
		arg.Name,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const UpdateUser = `-- name: UpdateUser :exec
update users set email = $1, name = $2, user_role = $3, password =$4, updated_at = clock_timestamp() where id = $5
`

type UpdateUserParams struct {
	Email    string       `json:"email"`
	Name     string       `json:"name"`
	UserRole UserRoleType `json:"userRole"`
	Password string       `json:"password"`
	ID       int64        `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, UpdateUser,
		arg.Email,
		arg.Name,
		arg.UserRole,
		arg.Password,
		arg.ID,
	)
	return err
}
